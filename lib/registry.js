#!/usr/bin/env node
// Generated by CoffeeScript 1.11.1
(function() {
  var BUMP_FACTOR, DEFAULT_HEARTBEAT, DEFAULT_REGISTRY_PORT, EventEmitter, REGISTRY_BIND_HOST, REGISTRY_BIND_PORT, REGISTRY_BIND_PROTO, Registry, VERBOSE, argv, async, checkServices, deregisterService, findServices, getHealthyServiceByName, getRemoteServiceByName, getService, getServiceByClientId, getServiceById, heartbeats, isHealthy, known_ping_clients, log, minimist, registerService, registered, registry, registry_methods, registry_options, remote_registered, somata,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  somata = require('somata');

  async = require('async');

  minimist = require('minimist');

  log = somata.log;

  EventEmitter = require('events').EventEmitter;

  argv = minimist(process.argv);

  DEFAULT_REGISTRY_PORT = 8420;

  DEFAULT_HEARTBEAT = 5000;

  BUMP_FACTOR = 1.5;

  VERBOSE = argv.v || argv.verbose || process.env.SOMATA_VERBOSE || false;

  REGISTRY_BIND_PROTO = argv.proto || process.env.SOMATA_REGISTRY_BIND_PROTO || 'tcp';

  REGISTRY_BIND_HOST = argv.host || process.env.SOMATA_REGISTRY_BIND_HOST || '127.0.0.1';

  REGISTRY_BIND_PORT = parseInt(argv.port || process.env.SOMATA_REGISTRY_BIND_PORT || DEFAULT_REGISTRY_PORT);

  registered = {};

  remote_registered = {};

  heartbeats = {};

  known_ping_clients = {};

  registerService = function(client_id, service_instance, cb) {
    var existing, name;
    service_instance.client_id = client_id;
    if (service_instance.heartbeat == null) {
      service_instance.heartbeat = DEFAULT_HEARTBEAT;
    }
    registered[name = service_instance.name] || (registered[name] = {});
    if (existing = registered[service_instance.name][service_instance.id]) {
      log.w('[registerService] Service exists', existing);
    }
    registered[service_instance.name][service_instance.id] = service_instance;
    heartbeats[client_id] = new Date().getTime() + service_instance.heartbeat * BUMP_FACTOR;
    log.s("[Registry.registerService] <" + client_id + "> as " + service_instance.id);
    registry.publish('register', service_instance);
    registry.emit('register', service_instance);
    return cb(null, service_instance);
  };

  deregisterService = function(service_name, service_id, cb) {
    var ping_id, ref, service_instance;
    log.w("[Registry.deregisterService] " + service_id);
    if (service_instance = (ref = registered[service_name]) != null ? ref[service_id] : void 0) {
      delete heartbeats[service_instance.client_id];
      delete registered[service_name][service_id];
      ping_id = known_ping_clients[service_instance.client_id];
      delete known_ping_clients[service_instance.client_id];
      delete registry.binding.known_pings[ping_id];
      registry.publish('deregister', service_instance);
      registry.emit('deregister', service_instance);
    }
    return typeof cb === "function" ? cb(null, service_id) : void 0;
  };

  isHealthy = function(service_instance) {
    var is_healthy, next_heartbeat;
    if (service_instance.heartbeat === 0) {
      return true;
    }
    next_heartbeat = heartbeats[service_instance.client_id];
    is_healthy = next_heartbeat > new Date().getTime();
    if (!is_healthy) {
      if (VERBOSE) {
        log.w("Heartbeat overdue by " + (new Date().getTime() - next_heartbeat));
      }
      deregisterService(service_instance.name, service_instance.id);
    }
    return is_healthy;
  };

  checkServices = function() {
    var results, service_id, service_instance, service_instances, service_name;
    results = [];
    for (service_name in registered) {
      service_instances = registered[service_name];
      results.push((function() {
        var results1;
        results1 = [];
        for (service_id in service_instances) {
          service_instance = service_instances[service_id];
          results1.push(isHealthy(service_instance));
        }
        return results1;
      })());
    }
    return results;
  };

  setInterval(checkServices, 500);

  findServices = function(cb) {
    return cb(null, registered);
  };

  getHealthyServiceByName = function(service_name) {
    var instance, service_id, service_instances;
    service_instances = registered[service_name];
    for (service_id in service_instances) {
      instance = service_instances[service_id];
      if (isHealthy(instance)) {
        return instance;
      }
    }
    return null;
  };

  getRemoteServiceByName = function(service_name) {
    var service_instances;
    service_instances = remote_registered[service_name];
    if ((service_instances != null) && Object.keys(service_instances).length) {
      return service_instances[Object.keys(service_instances)[0]];
    }
  };

  getServiceById = function(service_id) {
    var ref, service_name;
    service_name = service_id.split('~')[0];
    return (ref = registered[service_name]) != null ? ref[service_id] : void 0;
  };

  getServiceByClientId = function(client_id) {
    var instance, service_id, service_instances, service_name;
    for (service_name in registered) {
      service_instances = registered[service_name];
      for (service_id in service_instances) {
        instance = service_instances[service_id];
        if (instance.client_id === client_id) {
          return instance;
        }
      }
    }
    return null;
  };

  getService = function(service_name, cb) {
    var service_instance;
    if (service_instance = getHealthyServiceByName(service_name)) {
      return cb(null, service_instance);
    } else if (service_instance = getRemoteServiceByName(service_name)) {
      return cb(null, service_instance);
    } else {
      log.w("No healthy instances for " + service_name);
      return cb("No healthy instances for " + service_name);
    }
  };

  registry_methods = {
    registerService: registerService,
    deregisterService: deregisterService,
    findServices: findServices,
    getService: getService
  };

  registry_options = {
    binding_options: {
      proto: REGISTRY_BIND_PROTO,
      host: REGISTRY_BIND_HOST,
      port: REGISTRY_BIND_PORT
    }
  };

  Registry = (function(superClass) {
    extend(Registry, superClass);

    function Registry() {
      return Registry.__super__.constructor.apply(this, arguments);
    }

    Registry.prototype.register = function() {
      log.i("[Registry] Bound to " + REGISTRY_BIND_HOST + ":" + REGISTRY_BIND_PORT);
      if (VERBOSE) {
        log.d("[Registry.register] Who registers the registry?");
      }
      return this.binding.on('ping', this.handlePing.bind(this));
    };

    Registry.prototype.deregister = function(cb) {
      return cb();
    };

    Registry.prototype.handleMethod = function(client_id, message) {
      var service_instances;
      if (message.method === 'registerService') {
        return registerService.apply(null, [client_id].concat(slice.call(message.args), [(function(_this) {
          return function(err, response) {
            return _this.sendResponse(client_id, message.id, response);
          };
        })(this)]));
      } else if (message.method === 'registerServices') {
        service_instances = message.args[0];
        return async.map(service_instances, registerService.bind(null, client_id), (function(_this) {
          return function(err, response) {
            return _this.sendResponse(client_id, message.id, response);
          };
        })(this));
      } else {
        return Registry.__super__.handleMethod.apply(this, arguments);
      }
    };

    Registry.prototype.handlePing = function(client_id, message) {
      var heartbeat_interval, service_instance;
      known_ping_clients[client_id] = message.id;
      if (service_instance = getServiceByClientId(client_id)) {
        heartbeat_interval = service_instance.heartbeat;
        return heartbeats[client_id] = new Date().getTime() + heartbeat_interval * BUMP_FACTOR;
      }
    };

    return Registry;

  })(somata.Service);

  registry = new Registry('somata:registry', registry_methods, registry_options);

}).call(this);
